1. the main js file. It includes all other files.
2. views - files that create pieces of pages/UI. They are used by components. Include <template>, <script>, <style>.
3. components (Have the 3 parts (<template> (DOM), <script>, <style>).
4. DOM elements that are in every page. Have the 3 parts (<template>, <script>, <style>).
5. This is part of the PHP app. Webpack will not touch them.
6. "assets" folder. Holds all the generated files, i.e. the generated bundle: all the minimized script and style sheet and all images copied from src/images
7. only images used by the bundle are placed here.
8. the webpack configuration file. It is placed here so as not to clutter the root folder of the app.
9. do not deploy these to the prod server.
10. can be replaced with SASS
11. webpack, use this file as input
12. webpack, create the output file depending on the environment.
13. Resolving the path of the 'assets/' folder using a relative path, because the webpack configuration file itself is located in the 'src/build/' folder.
14. If in production, minimize the generated script.
15. If in prod, disable warnings that can be generated by code inserted by webpack.
16. devtool: if in Prod, don't use it. ELSE (in dev), generate source maps.
17. In prod mode we set the NODE_ENV variable to "production". This enables some optimizations in vue-loader.
18. pass this variable (NODE_ENV) to the DefinePlugin to remove unnecessary debugging code from Vue.js.
19. Webpack, process .vue files using vue-loader! (It will automatically convert HTML templates to JavaScript and handle embedded style sheets.)
20. Wepbpack, process .js files using Babel. I want to use the ES6 syntax in our .js files.
21. vue-loader also uses babel-loader under the hood, so we can use ES6 in .vue files as well.
22. Babel, use babel-env-preset, and leave module processing to webpack.
23. To be able to import .css and .sass files from .js files
24. to make images to be copied to the 'assets/images/' folder when the production bundle is created. Their original names will be preserved.
25. To reference images from your style sheets
26. Webpack, this is how to resolve paths when importing files.
27. file extensions which can be omitted.
28. The alias option is very powerful, but one particularly useful trick is defining @ as the alias of the "src/" folder. This way you don’t have to use relative paths with lots of "../."
29. This path is where our assets will be served. This URL (http://localhost:8080/js/main.js) will be the URL of our script. Port 8080 is default number for the webpack dev server. 
30. disable content base, i.e. only serve the files that are part of our bundle. Everything else will be served by Apache or IIS.
31. enable hot module replacement. It allows you to see your changes immediately without refreshing the page.
32. value must be '*'. This is necessary because our PHP application is running on a different port than the webpack development server. Without it, the browser would block the AJAX requests which fetch the updated scripts.
33. When in dev mode, do hot replacement
34. will minimize the generated JavaScript file.
35. load it because it’s not included in webpack
36. We add this plugin to the list of production plugins
37. specify the name of the generated CSS file:
38. the function to use the "ExtractTextPlugin" plugin (#36) with the style loaders. Note that this function should be placed inside the main function exported from the webpack configuration file, so that it can access the 'env' argument.
39. The "minimize" option for the css-loader: it is enabled in production mode, so the extracted CSS file will be minimized.
40. The function chains an additional style loader when the type argument is specified. This way we can handle Less or another style processor.
41. In prod mode, we pass these loaders to the text extraction plugin.
42. In dev mode we use the vue-style-loader which injects the styles into the page header and handles hot reloading.
43. In development mode we can simply add the following tag at the end of the body of the page which is generated by PHP to load the script:
44. The image was specified using a relative path, for example '../images/my-logo.png'. This path is automatically translated using the specified publicPath. This is how the webpack development server will serve any images which are included in our components or style sheets. 
45. When we deploy our PHP application to production, we will load the bundled styles and script from the assets/ folder.
46. We have to change the "publicPath" in production mode. Otherwise the image paths in the style sheet would refer to the development server. This way the translated path will be the same as the original one, for example '../images/my-logo.png'. This will work because our style sheet is placed in "assets/css/" and images are in "assets/images/".
47. Fortunately, the public path can be changed at run-time using the special "__webpack_public_path__" variable. We can set it at the beginning (!!!) of our script like this. We only do it in production mode, because in development the public path is already correctly set to http://localhost:8080/.
48. "cache busting" for the extracted JS: include the version of the file in the URL (as a query string), main.min.js?v=1. Webpack uses hashes based on file content to ensure that the URL changes whenever the file is updated.
49. "cache busting" for the extracted CSS
50. "cache busting" for the file loader
51. "cache busting" as part of file name. 
53. the plugin to extract hashes to use for "cache busting"
54. Add the plugin to our webpack configuration in production mode.
55. the file that the plugin will create. It has to be loaded in the PHP code and voilà! We can generate correct URLs which include these hashes.
56. Approach 1. Using custom HTML attributes to pass info. The script would have to scan the document, look for these attributes and create appropriate Vue.js components.
57. Approach 2. create components explicitly. This is simpler.
58. MyLibrary is the name of the global variable. This will let you use your Vue.js components wherever you need, just like you would use jQuery components.

https://codeburst.io/using-vue-js-components-in-php-applications-e5bfde8763bc


59. build.js. This is the build JS application. The only file (a bundle) that gets served to the client??? This file is built by webpack. Where is /dist/??? It is created in memory when in dev mode. It is visible when in the prod mode. It is the bundle containing all the .vue files, bundled into a single file for compactness.
60. .vue files. Get converted into JS files. Has <template>, <script>, <style>. After it gets converted into JS files, it is passed to h() in the main.js
61. index.js. The file with the html portion. It is the file that actually gets served. Pulls in the included built bundle (собранный пакет) from /dist/. What if I have vue instance A for page A of the existing PHP app, vue instance B for page B of the app, vue instance C for page C.  What does build.js contain? The js code for the templates used for all the pages of the app that use VueJS templates? Is it possible to ensure that page A has the built bundle with vue instance A, and page B has the bundle for vue instance B etc.? --- Is index.js necessary? Can I direct VueJS to different parts of the PHP application that have the ids? --- If I can do that, does that mean I would have to reference the /dist/build.js on every one of those pages?
62. main.js. Here you import Vuejs, create a Vue instance. Can have multiple Vue instances, one per each div#aaa. Does that mean I can have one single main.js for the whole PHP app? For all the pages? This single main.js serving all the pages that use VueJS?
63. Vuejs, mount the DOM element in the index.html that has the id of 'app' 
64. Vuejs, render the 'compiled' template contained inside the App.vue file on top of that #app
65. presence: optional. it is not related to the div#app in the <template>
66. presence: optional
67. this is the div where the application will be rendered
68. Transpiler from ES6 to normal JS.